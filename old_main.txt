// package main

// // This uses servemux which is a relatively new addition to Go's net/http package.
// // More mainstream option is to use gorilla/mux or chi router.
// import (
// 	"fmt"
// 	"log"
// 	"net/http"
// 	"strconv"
// )

// // Define a home handler function which writes a byte slice containing
// // "Hello from Snippetbox!" as the response body.
// //
// // *What is a ResponseWriter?
// // It is an interface type that allows us to construct an HTTP response which is used by the http handler.
// // It has methods for adding headers, setting cookies, and writing the response body. It is
// // passed to the handler by the http server.
// //
// // *What is a Request? It is a struct type that holds all the information
// // about the HTTP request(http method, url, headers, body etc) that was sent by the client.
// // Why it is a pointer and not a class?
// // Because there are no classes in Go, and using a pointer allows us to avoid copying the entire struct.
// func home(w http.ResponseWriter, r *http.Request) {
// 	// In Swift we use type Data, here we use byte slice.
// 	// It is similar to Swift's Data type which represents a contiguous block of memory.
// 	// What is byte slice?
// 	// A Slice is a data structure in Go that represents a dynamic array, which is represented by Array in Swift.
// 	// Whereas an Array in Go is a fixed-size sequence of elements of a specific type.
// 	// A Slice is declared using the syntax []sliceType and array as [arraySize]arrayType.
// 	// A byte slice is a slice whose elements are of type byte.
// 	// A byte is an alias for uint8, which means it is an unsigned 8-bit integer.
// 	// A byte slice is commonly used to represent binary data or text data in Go and single byte can represent a character.

// 	// Here we are converting the string "Hello from Snippetbox!" to a byte slice using []byte() conversion.
// 	// Then we write it to the ResponseWriter using the Write method.
// 	// The Write method writes the data to the connection as part of an HTTP reply.
// 	// It returns the number of bytes written and any error encountered.
// 	bytes, error := w.Write([]byte("Hello from Snippetbox!"))
// 	if error != nil {
// 		fmt.Println(error)
// 	} else {
// 		fmt.Println("Bytes written:", bytes)
// 	}
// }

// func snippetView(w http.ResponseWriter, r *http.Request) {
// 	id, err := strconv.Atoi(r.PathValue("id"))
// 	if err != nil || id < 1 {
// 		http.NotFound(w, r)
// 		return
// 	}
// 	msg := fmt.Sprintf("Display a specific snippet with ID %d", id)

// 	// using w.Write() to send specific HTTP response bodies to a user. And while this is the simplest and most fundamental way to send a response, in
// 	// practice it’s far more common to pass your http.ResponseWriter value to another function
// 	// that writes the response for you.

// 	// The key thing to understand is the http.ResponseWriter value in your
// 	// handlers has a Write() method, it satisfies the io.Writer interface.

// 	// That means you can use standard library functions like io.WriteString() and the
// 	// fmt.Fprint*() family (all of which accept an io.Writer parameter) to write plain-text
// 	// response bodies too.
// 	w.Write([]byte(msg))

// 	// Instead of this...
// 	// w.Write([]byte("Hello world"))
// 	// You can do this...
// 	// io.WriteString(w, "Hello world")
// 	fmt.Fprint(w, "Hello world")

// }

// func snippetCreate(w http.ResponseWriter, r *http.Request) {
// 	w.Write([]byte("Display a new form for creating a new snippet..."))
// }

// func snippetCreatePost(w http.ResponseWriter, r *http.Request) {
// 	w.Header().Set("Content-Type", "application/json")
// 	w.Header().Set("Server", "Go")

// 	w.WriteHeader(http.StatusCreated) // writeHeader must be called before write() as write sends the default 200. Can be called once per response.

// 	w.Write([]byte(`{"id": 123, "message": "Snippet successfully created!"}`))
// }

// func main() {
// 	// What is a router in web development?
// 	// A router is a component that maps incoming HTTP requests to specific handler functions based on the request's URL path and HTTP method.
// 	// In Go's net/http package, the default router is used when we call http.HandleFunc.
// 	// But we can use servemux too. What is servemux?
// 	// A ServeMux (short for "HTTP request multiplexer") is an HTTP request router provided by the net/http package in Go.

// 	mux := http.NewServeMux()
// 	// Register the home handler function for the "/" URL path.
// 	// When a route ends with "/" or "/static/" -- it is known as subtree path pattern.
// 	// the "/" route pattern acts like a catch-all. The pattern essentially
// 	// means match a single slash, followed by anything (or nothing at all).
// 	// mux.HandleFunc("/", home)
// 	// To prevent subtree path patterns from acting like they have a wildcard at the end, you can
// 	// append the special character sequence {$}
// 	// So if you have the route pattern "/{$}", it effectively means match a single slash, followed
// 	// by nothing else. It will only match requests where the URL path is exactly /.
// 	mux.HandleFunc("GET /{$}", home) // Restrict this route to exact matches on / only.

// 	// Now a request for an unregistered URL path like http://localhost:4000/foo/bar.
// 	// Will return a 404 Not Found response instead of being handled by the home handler.

// 	// Go's servemux has different matching rules depending on whether the pattern ends with a trailing slash or not.
// 	// If the pattern ends with a trailing slash (e.g., "/snippet/"), it matches any URL path that starts with that pattern.
// 	// If the pattern does not end with a trailing slash (e.g., "/snippet"), it matches only the exact URL path.
// 	mux.HandleFunc("GET /snippet/create", snippetCreate)

// 	mux.HandleFunc("GET /snippet/view/{id}", snippetView)

// 	mux.HandleFunc("POST /snippet/create", snippetCreatePost)

// 	log.Println("starting server on: 4000")

// 	// Start the HTTP server on port 4000 and use the mux as the handler.
// 	// The function takes two parameters: the TCP network address to listen on (in this case, ":4000" which means all interfaces on port 4000)
// 	// The default format is "host:port", in our case of localhost our computer we're supplying the port for all network interfaces connecting to port 4000.
// 	// and the handler to use (in this case, mux).
// 	// This is important to note that ListenAndServe is a blocking function, meaning it will run indefinitely until the program is terminated.
// 	// This will always return a non-nil error which means the server has stopped or failed at any stage during starting.
// 	err := http.ListenAndServe(":4000", mux)
// 	log.Fatal(err)
// }

// // ---------------------------
// // |  Extra notes:           |
// // ---------------------------
// //
// // ** err := http.ListenAndServe(":4000", mux) **
// //
// // In Go certain times we use named ports like :http or :http-alt instead of a number.
// // In this case the system will look up the port number in the /etc/services file on Unix-like systems
// // or the registry on Windows systems. For example, :http corresponds to port 80 and :https corresponds to port 443.
// // However, it is more common to use numeric port numbers directly, especially in development and testing environments.
// //
// // ---------------------------
// //
// // ** ServeMux Features: **
// //
// // 1. Request URL Paths are automatically sanitized. If request URL path contains any . or .. elements or repeated slashes, they are automatically redirected to an equivalent clean URL.
// // For example, if a user makes a request to /foo/bar/..//baz they will automatically be sent a 301 Permanent Redirect to /foo/baz instead.
// // 2. If a subtree path has been registered and a request is received for that subtree path without a trailing slash, then the user will
// // automatically be sent a 301 Permanent Redirect to the subtree path with the slash added. For example, if you
// // have registered the subtree path /foo/, then any request to /foo will be redirected to /foo/.
// //
// // ---------------------------
// //
// // ** Default ServeMux vs ServeMux: **
// //
// // Go provides two ways to create an HTTP server:
// // 1. Using the default ServeMux (the global one) by calling http.HandleFunc and http.ListenAndServe.
// // 2. Creating a custom ServeMux instance using http.NewServeMux() and passing it to http.ListenAndServe.
// //
// // Because http.DefaultServeMux is a global variable in the standard library, it means *any*
// // Go code in your project can access it and potentially register a route. If you have a large
// // project codebase (especially one that is being worked on by many people), that can
// // make it harder to ensure all route declarations for your application are easily
// // discoverable in one central place.
// // It also means that any third-party packages that your application imports can register
// // routes with http.DefaultServeMux too. If one of those third-party packages is
// // compromised, they could potentially use http.DefaultServeMux to expose a malicious
// // handler to the web. It’s simple to avoid this risk by just not using http.DefaultServeMux.